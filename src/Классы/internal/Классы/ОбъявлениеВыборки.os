
Перем ИсполнительЗапрос; 
Перем ДиалектЗапроса; // MSSQL / SQLite .. и т.д.
Перем ТекстЗапроса;

Перем Таблица;
Перем ПоляВыборки; // Структура

Перем СоединенияТаблиц; // Массив 

Перем УсловиеГде; // WHERE  
Перем Группировка; // GROUPE
Перем УсловиеИмеющие; // HAVING
Перем Упорядочивание; // ORDER

Перем Различные; // DISTINCT

Перем ЛимитВыборки; // FIRST 
Перем СмещениеВыборки; // Число

Перем Заполнитель;

Процедура УстановитьТекстЗапроса(Знач НовыйТекстЗапроса);

	ТекстЗапроса = НовыйТекстЗапроса;

КонецПроцедуры

Функция ПолучитьТекстЗапроса() Экспорт

	Возврат ТекстЗапроса;

КонецФункции

Функция Различные() Экспорт

	Различные = Истина;

	Возврат ЭтотОбъект;
	
КонецФункции

Функция Выбрать(Колонка1 = "",
				 Колонка2 = Неопределено,
				 Колонка3 = Неопределено,				 
				 Колонка4 = Неопределено,
				 Колонка5 = Неопределено,
				 Колонка6 = Неопределено,
				 Колонка7 = Неопределено,
				 Колонка8 = Неопределено,
				 Колонка9 = Неопределено
				 ) Экспорт

	ПоляВыборки = СтрРазделить(Колонка1, ",");

	Возврат ЭтотОбъект;

КонецФункции

Функция Колонка(ИмяПоля, ПредставлениеПоля = "") Экспорт

	СтрокаКолонки = ИмяПоля;

	Если НЕ ПустаяСтрока(Представление) Тогда
		СтрокаКолонки = СтрокаКолонки + " AS " + ПредставлениеПоля;
	КонецЕсли;

	ПоляВыборки.Добавить(СтрокаКолонки);

	Возврат ЭтотОбъект;

КонецФункции

Функция Соединение(ИмяТаблицыСоединения, ПравилоСоединения) Экспорт

	Возврат ПолноеСоединение(ИмяТаблицыСоединения, ПравилоСоединения);

КонецФункции

Функция ПолноеСоединение(ИмяТаблицыСоединения, ПравилоСоединения) Экспорт

	ДобавитьСоединение(ТипСоединенияТаблиц.Полное, ИмяТаблицыСоединения, ПравилоСоединения)

	Возврат ЭтотОбъект;

КонецФункции

Функция ЛевоеСоединение(ИмяТаблицыСоединения, ПравилоСоединения) Экспорт
	
	ДобавитьСоединение(ТипСоединенияТаблиц.Левое, ИмяТаблицыСоединения, ПравилоСоединения)

	Возврат ЭтотОбъект;

КонецФункции

Функция ПравоеСоединение(ИмяТаблицыСоединения, ПравилоСоединения) Экспорт

	ДобавитьСоединение(ТипСоединенияТаблиц.Правое, ИмяТаблицыСоединения, ПравилоСоединения)

	Возврат ЭтотОбъект;

КонецФункции

Процедура ДобавитьСоединение(ТипСоединенияТаблиц, ИмяТаблицыСоединения, ПравилоСоединения)
	
	НовоеСоединениеТаблиц = Новый СоединениеТаблиц(ТипСоединенияТаблиц, ИмяТаблицыСоединения, ПравилоСоединения);

	СоединенияТаблиц.Добавить(НовоеСоединениеТаблиц);

КонецПроцедуры

Процедура ПодготовитьТекстЗапроса()
	
	Если ЗначениеЗаполнено(ТекстЗапроса) Тогда
		
		Возврат;

	КонецЕсли;

	Если ПоляВыборки.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;

	БуферТекстаЗапроса = Новый БуферТекстаЗапроса;
	БуферТекстаЗапроса.ДобавитьТекст("SELECT ");
	
	Если Различные Тогда
		БуферТекстаЗапроса.ДобавитьТекст("DISTINCT ");
	КонецЕсли;

	БуферТекстаЗапроса.ДобавитьТекст(ТекстКолонокВыборка);
	
	ИндексПоляВыборки = 0;
	Для каждого ПолеВыборки Из ПоляВыборки Цикл
		
		Если ИндексПоляВыборки > 0 Тогда
			
			БуферТекстаЗапроса.ДобавитьТекст(", ");
	
		КонецЕсли;
		
		ДобавитьЗначениеВТекстЗапроса(БуферТекстаЗапроса, ПолеВыборки);

	КонецЦикла;

	Если ЗначениеЗаполнено(Таблица) Тогда
		
		БуферТекстаЗапроса.ДобавитьТекст(" FROM ");

		ДобавитьЗначениеВТекстЗапроса(БуферТекстаЗапроса, Таблица);

		Для каждого Соединение Из СоединенияТаблиц Цикл

			Соединение.Создать(ДиалектЗапроса, БуферТекстаЗапроса);

		КонецЦикла;

	КонецЕсли;


	// if len(b.WhereCond) > 0 {
	// 	buf.WriteString(" WHERE ")
	// 	err := And(b.WhereCond...).Build(d, buf)
	// 	if err != nil {
	// 		return err
	// 	}
	// }

	// if len(b.Group) > 0 {
	// 	buf.WriteString(" GROUP BY ")
	// 	for i, group := range b.Group {
	// 		if i > 0 {
	// 			buf.WriteString(", ")
	// 		}
	// 		err := group.Build(d, buf)
	// 		if err != nil {
	// 			return err
	// 		}
	// 	}
	// }

	// if len(b.HavingCond) > 0 {
	// 	buf.WriteString(" HAVING ")
	// 	err := And(b.HavingCond...).Build(d, buf)
	// 	if err != nil {
	// 		return err
	// 	}
	// }

	// if len(b.Order) > 0 {
	// 	buf.WriteString(" ORDER BY ")
	// 	for i, order := range b.Order {
	// 		if i > 0 {
	// 			buf.WriteString(", ")
	// 		}
	// 		err := order.Build(d, buf)
	// 		if err != nil {
	// 			return err
	// 		}
	// 	}
	// }


	Если ЛимитВыборки >= 0 Тогда
		БуферТекстаЗапроса.ДобавитьТекст(" LIMIT %1", ЛимитВыборки);	
	КонецЕсли;

	Если СмещениеВыборки >= 0 Тогда
		БуферТекстаЗапроса.ДобавитьТекст(" OFFSET %1", СмещениеВыборки);
	КонецЕсли;

КонецПроцедуры

Процедура ДобавитьЗначениеВТекстЗапроса(БуферТекстаЗапроса, Значение)
	
	Если ЭтоСтрока(Значение) Тогда
		
		БуферТекстаЗапроса.ДобавитьТекст(Значение);

	Иначе

		БуферТекстаЗапроса.ДобавитьТекст(Заполнитель);
		БуферТекстаЗапроса.ДобавитьЗначение(Значение);

	КонецЕсли;

КонецПроцедуры


Функция ЭтоСтрока(Знач ПроверяемоеЗначение)
	
	Возврат ТипыРавны(ТипЗнч(ПроверяемоеЗначение), Тип("Строка"));

КонецФункции

Функция ТипыРавны(ТипЛевый, ТипПравый)

	Возврат ТипЛевый = ТипПравый;
	
КонецФункции

Процедура ПриСозданииОбъекта()
	
	ЛимитВыборки = -1;
	СмещениеВыборки = -1;

	ТекстЗапроса = "";

	Таблица = Неопределено;
	
	СоединенияТаблиц = Новый Массив;
	
	УсловиеГде = Новый Массив;
	Группировка = Новый Массив;
	УсловиеИмеющие = Новый Массив;
	Упорядочивание = Новый Массив;

	Различные = Ложь;

	Заполнитель = КонстантыВыборки.Заполнитель;

КонецПроцедуры


// Select creates a SelectStmt.
func (sess *Session) Select(column ...string) *SelectStmt {
	b := Select(prepareSelect(column)...)
	b.runner = sess
	b.EventReceiver = sess
	b.Dialect = sess.Dialect
	return b
}



// // SelectBySql creates a SelectStmt from raw query.
// func SelectBySql(query string, value ...interface{}) *SelectStmt {
// 	return &SelectStmt{
// 		raw: raw{
// 			Query: query,
// 			Value: value,
// 		},
// 		LimitCount:  -1,
// 		OffsetCount: -1,
// 	}
// }



Функция Из(ТаблицаИлиОбъект) Экспорт
	
	Таблица = ТаблицаИлиОбъект;
	Возврат ЭтотОбъект;

КонецФункции

Функция Где(Знач Выражение, ЗначенияВыражения = Неопределено) Экспорт
	
	ДобавитьВыражение(УсловиеГде, Выражение, ЗначенияВыражения);
	
	Возврат ЭтотОбъект;

КонецФункции

Функция Имеющие(Знач Выражение, ЗначенияВыражения = Неопределено) Экспорт
	
	ДобавитьВыражение(УсловиеИмеющие, Выражение, ЗначенияВыражения);

	Возврат ЭтотОбъект;

КонецФункции

Функция ГруппироватьПо(Колонка1 = "",
					Колонка2 = Неопределено,
					Колонка3 = Неопределено,				 
					Колонка4 = Неопределено,
					Колонка5 = Неопределено,
					Колонка6 = Неопределено,
					Колонка7 = Неопределено,
					Колонка8 = Неопределено,
					Колонка9 = Неопределено
					) Экспорт
	
	ДобавитьВыражение(Группировка, Выражение, ЗначенияВыражения);

	Возврат ЭтотОбъект;

КонецФункции

Функция Группировать(Колонка1 = "",
					Колонка2 = Неопределено,
					Колонка3 = Неопределено,				 
					Колонка4 = Неопределено,
					Колонка5 = Неопределено,
					Колонка6 = Неопределено,
					Колонка7 = Неопределено,
					Колонка8 = Неопределено,
					Колонка9 = Неопределено
					) Экспорт

	ДобавитьВыражение(Группировка, Выражение, ЗначенияВыражения);

	Возврат ЭтотОбъект;

КонецФункции

Процедура ДобавитьВыражение(Приемник, Выражение, ЗначенияВыражения = Неопределено)

	Если ЭтоСтрока(Выражение) Тогда

		Приемник.Добавить(СоздатьВыражение(Выражение, ЗначенияВыражения));

	Иначе

		Приемник.Добавить(Выражение);

	КонецЕсли;

КонецПроцедуры

Функция СоздатьВыражение(Выражение, ЗначенияВыражения = Неопределено)
	
	// TODO: Написать создатель выражений
	НовоеВыражение = Новый СоздательВыражения(Выражение, ЗначенияВыражения);

	Возврат НовоеВыражение;

КонецФункции

Функция УпорядочитьПо(Знач ИмяПоляВыборки) Экспорт
	
	ДобавитьВыражение(Упорядочивание, ИмяПоляВыборки);

	Возврат ЭтотОбъект;

КонецФункции

Функция УпорядочитьВозр(Знач ИмяПоляВыборки) Экспорт
	
	ДобавитьВыражение(Упорядочивание, ИмяПоляВыборки, "DESC");

	Возврат ЭтотОбъект;

КонецФункции

Функция УпорядочитьУбыв(Знач ИмяПоляВыборки) Экспорт
	
	ДобавитьВыражение(Упорядочивание, ИмяПоляВыборки, "ASC");

	Возврат ЭтотОбъект;

КонецФункции

Функция Лимит(Знач ЗначениеЛимита) Экспорт
	
	ЛимитВыборки = ЗначениеЛимита;

	Возврат ЭтотОбъект;

КонецФункции

Функция Смещение(Знач ЗначениеСмещения) Экспорт
	
	СмещениеВыборки = ЗначениеСмещения;

	Возврат ЭтотОбъект;

КонецФункции

Функция РазбиватьНаСтраницы(Знач НомерСтраницы, Знач КоличествоНаСтранице) Экспорт
	
	Лимит(КоличествоНаСтранице);
	Смещение((НомерСтраницы - 1) * КоличествоНаСтранице));

	Возврат ЭтотОбъект;

КонецФункции

Функция Как(Знач Псевдоним) Экспорт
	
	Возврат Новый СоздательПсевдонима(ЭтотОбъект, Псевдоним);

КонецФункции

Функция Псевдоним(Знач НовыйПсевдоним) Экспорт
	
	Возврат Как(НовыйПсевдоним);

КонецФункции

// Rows executes the query and returns the rows returned, or any error encountered.
func (b *SelectStmt) Rows() (*sql.Rows, error) {
	return b.RowsContext(context.Background())
}

func (b *SelectStmt) RowsContext(ctx context.Context) (*sql.Rows, error) {
	_, rows, err := queryRows(ctx, b.runner, b.EventReceiver, b, b.Dialect)
	return rows, err
}

func (b *SelectStmt) LoadOneContext(ctx context.Context, value interface{}) error {
	count, err := query(ctx, b.runner, b.EventReceiver, b, b.Dialect, value)
	if err != nil {
		return err
	}
	if count == 0 {
		return ErrNotFound
	}
	return nil
}

// LoadOne loads SQL result into go variable that is not a slice.
// Unlike Load, it returns ErrNotFound if the SQL result row count is 0.
//
// See https://godoc.org/github.com/gocraft/dbr#Load.
func (b *SelectStmt) LoadOne(value interface{}) error {
	return b.LoadOneContext(context.Background(), value)
}

func (b *SelectStmt) LoadContext(ctx context.Context, value interface{}) (int, error) {
	return query(ctx, b.runner, b.EventReceiver, b, b.Dialect, value)
}

// Load loads multi-row SQL result into a slice of go variables.
//
// See https://godoc.org/github.com/gocraft/dbr#Load.
func (b *SelectStmt) Load(value interface{}) (int, error) {
	return b.LoadContext(context.Background(), value)
}

